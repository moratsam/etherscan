// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dbspgraph/proto/api.proto

package proto

import (
	context "context"
	fmt "fmt"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// The type of this step.
type Step_Type int32

const (
	Step_INVALID Step_Type = 0
	// This step corresponds to the PRE step of the executor callback.
	Step_PRE Step_Type = 1
	// This step corresponds to the POST step of the executor callback.
	Step_POST Step_Type = 2
	// This step corresponds to the POST_KEEP_RUNNING step of the executor
	// callback.
	Step_POST_KEEP_RUNNING Step_Type = 3
	// This step indicates to the master that the worker has successfully
	// completed the graph execution and is ready to persist the computation
	// results.
	Step_EXECUTED_GRAPH Step_Type = 4
	// This step indicates to the master that the worker has successfully
	// persisted the computation results.
	Step_PESISTED_RESULTS Step_Type = 5
	// This step indicates to the master that the worker has completed the job.
	Step_COMPLETED_JOB Step_Type = 6
)

var Step_Type_name = map[int32]string{
	0: "INVALID",
	1: "PRE",
	2: "POST",
	3: "POST_KEEP_RUNNING",
	4: "EXECUTED_GRAPH",
	5: "PESISTED_RESULTS",
	6: "COMPLETED_JOB",
}

var Step_Type_value = map[string]int32{
	"INVALID":           0,
	"PRE":               1,
	"POST":              2,
	"POST_KEEP_RUNNING": 3,
	"EXECUTED_GRAPH":    4,
	"PESISTED_RESULTS":  5,
	"COMPLETED_JOB":     6,
}

func (x Step_Type) String() string {
	return proto.EnumName(Step_Type_name, int32(x))
}

func (Step_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_25504a2d4be7f3d6, []int{3, 0}
}

// WorkerPayload encapsulates the possible message types that a worker can
// send to a master node.
type WorkerPayload struct {
	// Types that are valid to be assigned to Payload:
	//	*WorkerPayload_Step
	//	*WorkerPayload_RelayMessage
	Payload              isWorkerPayload_Payload `protobuf_oneof:"payload"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *WorkerPayload) Reset()         { *m = WorkerPayload{} }
func (m *WorkerPayload) String() string { return proto.CompactTextString(m) }
func (*WorkerPayload) ProtoMessage()    {}
func (*WorkerPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_25504a2d4be7f3d6, []int{0}
}
func (m *WorkerPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkerPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkerPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerPayload.Merge(m, src)
}
func (m *WorkerPayload) XXX_Size() int {
	return m.Size()
}
func (m *WorkerPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerPayload.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerPayload proto.InternalMessageInfo

type isWorkerPayload_Payload interface {
	isWorkerPayload_Payload()
	MarshalTo([]byte) (int, error)
	Size() int
}

type WorkerPayload_Step struct {
	Step *Step `protobuf:"bytes,1,opt,name=step,proto3,oneof" json:"step,omitempty"`
}
type WorkerPayload_RelayMessage struct {
	RelayMessage *RelayMessage `protobuf:"bytes,2,opt,name=relay_message,json=relayMessage,proto3,oneof" json:"relay_message,omitempty"`
}

func (*WorkerPayload_Step) isWorkerPayload_Payload()         {}
func (*WorkerPayload_RelayMessage) isWorkerPayload_Payload() {}

func (m *WorkerPayload) GetPayload() isWorkerPayload_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *WorkerPayload) GetStep() *Step {
	if x, ok := m.GetPayload().(*WorkerPayload_Step); ok {
		return x.Step
	}
	return nil
}

func (m *WorkerPayload) GetRelayMessage() *RelayMessage {
	if x, ok := m.GetPayload().(*WorkerPayload_RelayMessage); ok {
		return x.RelayMessage
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*WorkerPayload) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*WorkerPayload_Step)(nil),
		(*WorkerPayload_RelayMessage)(nil),
	}
}

// MasterPayload encapsulates the possible message types that a master can
// send to a worker node.
type MasterPayload struct {
	// Types that are valid to be assigned to Payload:
	//	*MasterPayload_JobDetails
	//	*MasterPayload_Step
	//	*MasterPayload_RelayMessage
	Payload              isMasterPayload_Payload `protobuf_oneof:"payload"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *MasterPayload) Reset()         { *m = MasterPayload{} }
func (m *MasterPayload) String() string { return proto.CompactTextString(m) }
func (*MasterPayload) ProtoMessage()    {}
func (*MasterPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_25504a2d4be7f3d6, []int{1}
}
func (m *MasterPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MasterPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MasterPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MasterPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MasterPayload.Merge(m, src)
}
func (m *MasterPayload) XXX_Size() int {
	return m.Size()
}
func (m *MasterPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_MasterPayload.DiscardUnknown(m)
}

var xxx_messageInfo_MasterPayload proto.InternalMessageInfo

type isMasterPayload_Payload interface {
	isMasterPayload_Payload()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MasterPayload_JobDetails struct {
	JobDetails *JobDetails `protobuf:"bytes,1,opt,name=job_details,json=jobDetails,proto3,oneof" json:"job_details,omitempty"`
}
type MasterPayload_Step struct {
	Step *Step `protobuf:"bytes,2,opt,name=step,proto3,oneof" json:"step,omitempty"`
}
type MasterPayload_RelayMessage struct {
	RelayMessage *RelayMessage `protobuf:"bytes,3,opt,name=relay_message,json=relayMessage,proto3,oneof" json:"relay_message,omitempty"`
}

func (*MasterPayload_JobDetails) isMasterPayload_Payload()   {}
func (*MasterPayload_Step) isMasterPayload_Payload()         {}
func (*MasterPayload_RelayMessage) isMasterPayload_Payload() {}

func (m *MasterPayload) GetPayload() isMasterPayload_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *MasterPayload) GetJobDetails() *JobDetails {
	if x, ok := m.GetPayload().(*MasterPayload_JobDetails); ok {
		return x.JobDetails
	}
	return nil
}

func (m *MasterPayload) GetStep() *Step {
	if x, ok := m.GetPayload().(*MasterPayload_Step); ok {
		return x.Step
	}
	return nil
}

func (m *MasterPayload) GetRelayMessage() *RelayMessage {
	if x, ok := m.GetPayload().(*MasterPayload_RelayMessage); ok {
		return x.RelayMessage
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MasterPayload) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MasterPayload_JobDetails)(nil),
		(*MasterPayload_Step)(nil),
		(*MasterPayload_RelayMessage)(nil),
	}
}

// JobDetails describes a job assigned by a master node to a worker.
type JobDetails struct {
	// A unique ID for the job.
	JobId string `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	// The creation time for the job.
	CreatedAt *types.Timestamp `protobuf:"bytes,2,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// The [fromAddress, toAddress) wallet address range assigned to the worker.
	// Note that from is inclusive and to is exclusive.
	PartitionFromAddr    string   `protobuf:"bytes,3,opt,name=PartitionFromAddr,proto3" json:"PartitionFromAddr,omitempty"`
	PartitionToAddr      string   `protobuf:"bytes,4,opt,name=PartitionToAddr,proto3" json:"PartitionToAddr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *JobDetails) Reset()         { *m = JobDetails{} }
func (m *JobDetails) String() string { return proto.CompactTextString(m) }
func (*JobDetails) ProtoMessage()    {}
func (*JobDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_25504a2d4be7f3d6, []int{2}
}
func (m *JobDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobDetails.Merge(m, src)
}
func (m *JobDetails) XXX_Size() int {
	return m.Size()
}
func (m *JobDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_JobDetails.DiscardUnknown(m)
}

var xxx_messageInfo_JobDetails proto.InternalMessageInfo

func (m *JobDetails) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *JobDetails) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *JobDetails) GetPartitionFromAddr() string {
	if m != nil {
		return m.PartitionFromAddr
	}
	return ""
}

func (m *JobDetails) GetPartitionToAddr() string {
	if m != nil {
		return m.PartitionToAddr
	}
	return ""
}

// Step describes the current state of a worker or a master. Workers send a
// Step message with their current state to enter a synchronization barrier
// and wait for the other workers. Once all workers reach the barrier, the
// master node (depending on the step type) processes the individual worker
// steps to update its global state and broadcasts a new Step message (with
// a matching step type) to notify the workers that they can exit the barrier.
type Step struct {
	// The type of this step.
	Type Step_Type `protobuf:"varint,1,opt,name=type,proto3,enum=proto.Step_Type" json:"type,omitempty"`
	// Workers use this field to submit their local aggregator delta values wen
	// reaching the POST step. The master collects the deltas, aggregates them to
	// its own aggregator values and broadcasts the global aggregator values in
	// the response. Workers must then *overwrite* their local aggregator values
	// with the values provided by the master.
	AggregatorValues map[string]*types.Any `protobuf:"bytes,2,rep,name=aggregator_values,json=aggregatorValues,proto3" json:"aggregator_values,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Workers use this field to submit their local active-in-step count when
	// reaching the POST_KEEP_RUNNING step. The step response broadcasted by
	// the master uses the same field to specify the global active-in-step count
	// that the workers should pass to the graph executor callbacks.
	// Active-in-step refers to the number of vertices that are still active.
	ActiveInStep         int64    `protobuf:"varint,3,opt,name=activeInStep,proto3" json:"activeInStep,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Step) Reset()         { *m = Step{} }
func (m *Step) String() string { return proto.CompactTextString(m) }
func (*Step) ProtoMessage()    {}
func (*Step) Descriptor() ([]byte, []int) {
	return fileDescriptor_25504a2d4be7f3d6, []int{3}
}
func (m *Step) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Step) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Step.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Step) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Step.Merge(m, src)
}
func (m *Step) XXX_Size() int {
	return m.Size()
}
func (m *Step) XXX_DiscardUnknown() {
	xxx_messageInfo_Step.DiscardUnknown(m)
}

var xxx_messageInfo_Step proto.InternalMessageInfo

func (m *Step) GetType() Step_Type {
	if m != nil {
		return m.Type
	}
	return Step_INVALID
}

func (m *Step) GetAggregatorValues() map[string]*types.Any {
	if m != nil {
		return m.AggregatorValues
	}
	return nil
}

func (m *Step) GetActiveInStep() int64 {
	if m != nil {
		return m.ActiveInStep
	}
	return 0
}

// RelayMessage describes a graph message that should be relayed to a remote
// graph instance which is managed by another worker.
type RelayMessage struct {
	// The message destination address.
	Destination string `protobuf:"bytes,1,opt,name=destination,proto3" json:"destination,omitempty"`
	// The serialized message contents.
	Message              *types.Any `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RelayMessage) Reset()         { *m = RelayMessage{} }
func (m *RelayMessage) String() string { return proto.CompactTextString(m) }
func (*RelayMessage) ProtoMessage()    {}
func (*RelayMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_25504a2d4be7f3d6, []int{4}
}
func (m *RelayMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RelayMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RelayMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RelayMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RelayMessage.Merge(m, src)
}
func (m *RelayMessage) XXX_Size() int {
	return m.Size()
}
func (m *RelayMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_RelayMessage.DiscardUnknown(m)
}

var xxx_messageInfo_RelayMessage proto.InternalMessageInfo

func (m *RelayMessage) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *RelayMessage) GetMessage() *types.Any {
	if m != nil {
		return m.Message
	}
	return nil
}

func init() {
	proto.RegisterEnum("proto.Step_Type", Step_Type_name, Step_Type_value)
	proto.RegisterType((*WorkerPayload)(nil), "proto.WorkerPayload")
	proto.RegisterType((*MasterPayload)(nil), "proto.MasterPayload")
	proto.RegisterType((*JobDetails)(nil), "proto.JobDetails")
	proto.RegisterType((*Step)(nil), "proto.Step")
	proto.RegisterMapType((map[string]*types.Any)(nil), "proto.Step.AggregatorValuesEntry")
	proto.RegisterType((*RelayMessage)(nil), "proto.RelayMessage")
}

func init() { proto.RegisterFile("dbspgraph/proto/api.proto", fileDescriptor_25504a2d4be7f3d6) }

var fileDescriptor_25504a2d4be7f3d6 = []byte{
	// 633 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x93, 0x41, 0x53, 0xd3, 0x4e,
	0x18, 0xc6, 0x9b, 0x36, 0xa5, 0xf4, 0x2d, 0xe5, 0x9f, 0xee, 0x1f, 0x66, 0xa0, 0x87, 0x0a, 0x1d,
	0x0f, 0x1d, 0xc7, 0x09, 0x4e, 0xf5, 0xa0, 0x78, 0x2a, 0x10, 0x69, 0x2b, 0x94, 0xb8, 0x29, 0xa8,
	0xa7, 0xb8, 0x21, 0x6b, 0x0c, 0xb4, 0xd9, 0xcc, 0x66, 0xcb, 0x4c, 0xfc, 0x24, 0x7e, 0x0b, 0x6f,
	0x7e, 0x06, 0x8f, 0x7e, 0x04, 0x07, 0x3f, 0x84, 0x57, 0x27, 0x9b, 0xb4, 0xb4, 0xc0, 0x45, 0x4f,
	0xdd, 0x3c, 0xcf, 0x6f, 0x77, 0x9f, 0xf7, 0x7d, 0xbb, 0xb0, 0xe9, 0x3a, 0x51, 0xe8, 0x71, 0x12,
	0x7e, 0xda, 0x09, 0x39, 0x13, 0x6c, 0x87, 0x84, 0xbe, 0x2e, 0x57, 0xa8, 0x28, 0x7f, 0xea, 0x0f,
	0x3c, 0xc6, 0xbc, 0x11, 0x4d, 0x6d, 0x67, 0xf2, 0x71, 0x47, 0xf8, 0x63, 0x1a, 0x09, 0x32, 0x0e,
	0x53, 0xae, 0xbe, 0x79, 0x1b, 0x20, 0x41, 0x9c, 0x5a, 0xcd, 0x18, 0xaa, 0x6f, 0x19, 0xbf, 0xa4,
	0xdc, 0x24, 0xf1, 0x88, 0x11, 0x17, 0x6d, 0x83, 0x1a, 0x09, 0x1a, 0x6e, 0x28, 0x5b, 0x4a, 0xab,
	0xd2, 0xae, 0xa4, 0x98, 0x6e, 0x09, 0x1a, 0x76, 0x73, 0x58, 0x5a, 0x68, 0x17, 0xaa, 0x9c, 0x8e,
	0x48, 0x6c, 0x8f, 0x69, 0x14, 0x11, 0x8f, 0x6e, 0xe4, 0x25, 0xfb, 0x7f, 0xc6, 0xe2, 0xc4, 0x3b,
	0x4e, 0xad, 0x6e, 0x0e, 0xaf, 0xf0, 0xb9, 0xef, 0xbd, 0x32, 0x94, 0xc2, 0xf4, 0xa6, 0xe6, 0x57,
	0x05, 0xaa, 0xc7, 0x24, 0x12, 0x37, 0x77, 0x3f, 0x83, 0xca, 0x05, 0x73, 0x6c, 0x97, 0x0a, 0xe2,
	0x8f, 0xa2, 0x2c, 0x42, 0x2d, 0x3b, 0xb6, 0xcf, 0x9c, 0x83, 0xd4, 0xe8, 0xe6, 0x30, 0x5c, 0xcc,
	0xbe, 0x66, 0x89, 0xf3, 0x7f, 0x91, 0xb8, 0xf0, 0x4f, 0x89, 0xbf, 0x29, 0x00, 0x37, 0x31, 0xd0,
	0x3a, 0x2c, 0x25, 0x71, 0x7d, 0x57, 0x26, 0x2d, 0xe3, 0xe2, 0x05, 0x73, 0x7a, 0x2e, 0x7a, 0x01,
	0x70, 0xce, 0x29, 0x11, 0xd4, 0xb5, 0x89, 0xc8, 0x52, 0xd5, 0xf5, 0x74, 0x04, 0xfa, 0x74, 0x04,
	0xfa, 0x70, 0x3a, 0x23, 0x5c, 0xce, 0xe8, 0x8e, 0x40, 0x8f, 0xa1, 0x66, 0x12, 0x2e, 0x7c, 0xe1,
	0xb3, 0xe0, 0x15, 0x67, 0xe3, 0x8e, 0xeb, 0x72, 0x99, 0xb5, 0x8c, 0xef, 0x1a, 0xa8, 0x05, 0xff,
	0xcd, 0xc4, 0x21, 0x93, 0xac, 0x2a, 0xd9, 0xdb, 0x72, 0xf3, 0x77, 0x1e, 0xd4, 0xa4, 0x21, 0xe8,
	0x21, 0xa8, 0x22, 0x0e, 0xa9, 0x0c, 0xbc, 0xda, 0xd6, 0xe6, 0x7a, 0xa5, 0x0f, 0xe3, 0x90, 0x62,
	0xe9, 0xa2, 0x01, 0xd4, 0x88, 0xe7, 0x71, 0xea, 0x11, 0xc1, 0xb8, 0x7d, 0x45, 0x46, 0x13, 0x1a,
	0x6d, 0xe4, 0xb7, 0x0a, 0xad, 0x4a, 0x7b, 0x7b, 0x7e, 0x4b, 0x67, 0x06, 0x9d, 0x49, 0xc6, 0x08,
	0x04, 0x8f, 0xb1, 0x46, 0x6e, 0xc9, 0xa8, 0x09, 0x2b, 0xe4, 0x5c, 0xf8, 0x57, 0xb4, 0x17, 0x24,
	0xfb, 0x64, 0x45, 0x05, 0xbc, 0xa0, 0xd5, 0xdf, 0xc3, 0xfa, 0xbd, 0xc7, 0x21, 0x0d, 0x0a, 0x97,
	0x34, 0xce, 0x5a, 0x9c, 0x2c, 0xd1, 0x23, 0x28, 0xca, 0x4c, 0x59, 0x6f, 0xd7, 0xee, 0xf4, 0xb6,
	0x13, 0xc4, 0x38, 0x45, 0x76, 0xf3, 0xcf, 0x95, 0xe6, 0x67, 0x50, 0x93, 0xe2, 0x50, 0x05, 0x4a,
	0xbd, 0xc1, 0x59, 0xe7, 0xa8, 0x77, 0xa0, 0xe5, 0x50, 0x09, 0x0a, 0x26, 0x36, 0x34, 0x05, 0x2d,
	0x83, 0x6a, 0x9e, 0x58, 0x43, 0x2d, 0x8f, 0xd6, 0xa1, 0x96, 0xac, 0xec, 0xd7, 0x86, 0x61, 0xda,
	0xf8, 0x74, 0x30, 0xe8, 0x0d, 0x0e, 0xb5, 0x02, 0x42, 0xb0, 0x6a, 0xbc, 0x33, 0xf6, 0x4f, 0x87,
	0xc6, 0x81, 0x7d, 0x88, 0x3b, 0x66, 0x57, 0x53, 0xd1, 0x1a, 0x68, 0xa6, 0x61, 0xf5, 0xac, 0x44,
	0xc3, 0x86, 0x75, 0x7a, 0x34, 0xb4, 0xb4, 0x22, 0xaa, 0x41, 0x75, 0xff, 0xe4, 0xd8, 0x3c, 0x32,
	0x12, 0xb9, 0x7f, 0xb2, 0xa7, 0x2d, 0x35, 0x3f, 0xc0, 0xca, 0xfc, 0xbf, 0x0b, 0x6d, 0x41, 0xc5,
	0xa5, 0x91, 0xf0, 0x03, 0x92, 0x8c, 0x27, 0xab, 0x6a, 0x5e, 0x42, 0x3a, 0x94, 0x16, 0xdf, 0xd5,
	0xfd, 0xf5, 0x4d, 0xa1, 0xf6, 0x21, 0x2c, 0xf7, 0x99, 0xf3, 0x66, 0x42, 0x27, 0x14, 0xbd, 0x84,
	0x72, 0x9f, 0x39, 0x96, 0xe0, 0x94, 0x8c, 0xd1, 0x5a, 0x36, 0xaa, 0x85, 0xf7, 0x5d, 0x9f, 0xaa,
	0x0b, 0x2f, 0xaf, 0xa5, 0x3c, 0x51, 0xf6, 0xb4, 0xef, 0xd7, 0x0d, 0xe5, 0xc7, 0x75, 0x43, 0xf9,
	0x79, 0xdd, 0x50, 0xbe, 0xfc, 0x6a, 0xe4, 0x9c, 0x25, 0x89, 0x3e, 0xfd, 0x13, 0x00, 0x00, 0xff,
	0xff, 0x25, 0xd6, 0xcb, 0x21, 0x83, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// JobQueueClient is the client API for JobQueue service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type JobQueueClient interface {
	// JobStream establishes a bi-directional connection between a worker and a
	// master. The master eventually broadcasts a new job to the connected
	// workers and the job super-steps are executed in lock-step across all
	// workers.
	JobStream(ctx context.Context, opts ...grpc.CallOption) (JobQueue_JobStreamClient, error)
}

type jobQueueClient struct {
	cc *grpc.ClientConn
}

func NewJobQueueClient(cc *grpc.ClientConn) JobQueueClient {
	return &jobQueueClient{cc}
}

func (c *jobQueueClient) JobStream(ctx context.Context, opts ...grpc.CallOption) (JobQueue_JobStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_JobQueue_serviceDesc.Streams[0], "/proto.JobQueue/JobStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &jobQueueJobStreamClient{stream}
	return x, nil
}

type JobQueue_JobStreamClient interface {
	Send(*WorkerPayload) error
	Recv() (*MasterPayload, error)
	grpc.ClientStream
}

type jobQueueJobStreamClient struct {
	grpc.ClientStream
}

func (x *jobQueueJobStreamClient) Send(m *WorkerPayload) error {
	return x.ClientStream.SendMsg(m)
}

func (x *jobQueueJobStreamClient) Recv() (*MasterPayload, error) {
	m := new(MasterPayload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// JobQueueServer is the server API for JobQueue service.
type JobQueueServer interface {
	// JobStream establishes a bi-directional connection between a worker and a
	// master. The master eventually broadcasts a new job to the connected
	// workers and the job super-steps are executed in lock-step across all
	// workers.
	JobStream(JobQueue_JobStreamServer) error
}

// UnimplementedJobQueueServer can be embedded to have forward compatible implementations.
type UnimplementedJobQueueServer struct {
}

func (*UnimplementedJobQueueServer) JobStream(srv JobQueue_JobStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method JobStream not implemented")
}

func RegisterJobQueueServer(s *grpc.Server, srv JobQueueServer) {
	s.RegisterService(&_JobQueue_serviceDesc, srv)
}

func _JobQueue_JobStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(JobQueueServer).JobStream(&jobQueueJobStreamServer{stream})
}

type JobQueue_JobStreamServer interface {
	Send(*MasterPayload) error
	Recv() (*WorkerPayload, error)
	grpc.ServerStream
}

type jobQueueJobStreamServer struct {
	grpc.ServerStream
}

func (x *jobQueueJobStreamServer) Send(m *MasterPayload) error {
	return x.ServerStream.SendMsg(m)
}

func (x *jobQueueJobStreamServer) Recv() (*WorkerPayload, error) {
	m := new(WorkerPayload)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _JobQueue_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.JobQueue",
	HandlerType: (*JobQueueServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "JobStream",
			Handler:       _JobQueue_JobStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "dbspgraph/proto/api.proto",
}

func (m *WorkerPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Payload != nil {
		{
			size := m.Payload.Size()
			i -= size
			if _, err := m.Payload.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *WorkerPayload_Step) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerPayload_Step) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Step != nil {
		{
			size, err := m.Step.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *WorkerPayload_RelayMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerPayload_RelayMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RelayMessage != nil {
		{
			size, err := m.RelayMessage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MasterPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MasterPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MasterPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Payload != nil {
		{
			size := m.Payload.Size()
			i -= size
			if _, err := m.Payload.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MasterPayload_JobDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MasterPayload_JobDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JobDetails != nil {
		{
			size, err := m.JobDetails.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *MasterPayload_Step) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MasterPayload_Step) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Step != nil {
		{
			size, err := m.Step.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MasterPayload_RelayMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MasterPayload_RelayMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RelayMessage != nil {
		{
			size, err := m.RelayMessage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *JobDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PartitionToAddr) > 0 {
		i -= len(m.PartitionToAddr)
		copy(dAtA[i:], m.PartitionToAddr)
		i = encodeVarintApi(dAtA, i, uint64(len(m.PartitionToAddr)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PartitionFromAddr) > 0 {
		i -= len(m.PartitionFromAddr)
		copy(dAtA[i:], m.PartitionFromAddr)
		i = encodeVarintApi(dAtA, i, uint64(len(m.PartitionFromAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintApi(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Step) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Step) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Step) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ActiveInStep != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ActiveInStep))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AggregatorValues) > 0 {
		for k := range m.AggregatorValues {
			v := m.AggregatorValues[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RelayMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelayMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RelayMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Destination) > 0 {
		i -= len(m.Destination)
		copy(dAtA[i:], m.Destination)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Destination)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *WorkerPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		n += m.Payload.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkerPayload_Step) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Step != nil {
		l = m.Step.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *WorkerPayload_RelayMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RelayMessage != nil {
		l = m.RelayMessage.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *MasterPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		n += m.Payload.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MasterPayload_JobDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobDetails != nil {
		l = m.JobDetails.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *MasterPayload_Step) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Step != nil {
		l = m.Step.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *MasterPayload_RelayMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RelayMessage != nil {
		l = m.RelayMessage.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *JobDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.PartitionFromAddr)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.PartitionToAddr)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Step) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if len(m.AggregatorValues) > 0 {
		for k, v := range m.AggregatorValues {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.ActiveInStep != 0 {
		n += 1 + sovApi(uint64(m.ActiveInStep))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RelayMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *WorkerPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Step{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &WorkerPayload_Step{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RelayMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &WorkerPayload_RelayMessage{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MasterPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MasterPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MasterPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &MasterPayload_JobDetails{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Step{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &MasterPayload_Step{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RelayMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &MasterPayload_RelayMessage{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionFromAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionFromAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionToAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionToAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Step) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Step: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Step: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Step_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregatorValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AggregatorValues == nil {
				m.AggregatorValues = make(map[string]*types.Any)
			}
			var mapkey string
			var mapvalue *types.Any
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &types.Any{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AggregatorValues[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveInStep", wireType)
			}
			m.ActiveInStep = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveInStep |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelayMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelayMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelayMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &types.Any{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)
